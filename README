Ελευθέριος-Αργύριος Καραμπάς		 ΑΜ: 1115201400064

Προγραμματισμός Συστήματος 			Project2

Για την υλοποίηση αυτής της εργασίας δούλεψα ως εξής:

1) Named-pipes μεταξύ jms_console και jms_coord: Το πρόγραμμα μου έχει τη δυνατότητα να ξεκινάμε είτε τον jms_coord είτε τον jms_console πρώτα, καθώς το κάθε ένα πρόγραμμα δημιουργεί το δικό του reading pipe και περιμένει σε ένα while loop ώστε να δημιουργήσει και το άλλο πρόγραμμα το δικό του reading pipe. Κατα τον τερματισμό των προγραμμάτων το jms_console διαγράφει και τα 2 named_pipes.

2) Επικοινωνία jms_console – jms_coord: Αφου δημιουργηθούν και ανοίξουν και τα 2 named_pipes τότε ο jms_coord περιμένει να του στείλει ο jms_console το pid του ώστε να το χρησιμοποιήσει στην μετάπειτα επικοινωνία.
Στη συνέχεια ο jms_console διαβάζει εντολές και τις στέλνει, μέσω του named-pipe, μία μία περιμένοντας να πάρει απάντηση μέσω του άλλου named_pipe και να δεχτεί SIGTERM signal που με κατάλληλο signal handler αλλάζει μία volatile (θα μπορούσε να ήταν και μία απλή global, αφού δεν έχουμε multi-threading programming στην περίπτωση μας) μεταβλητή. Με αυτόν τον τρόπο γνωρίζει οτι ο coord τελείωσε με την απάντηση και οτι είναι έτοιμος να στείλει την επόμενη εντολή.

Αντίστοιχα ο jms_coord δέχεται την εντολή την διαβάζει και αναλόγως τι εντολή είναι κάνει και τις αντίστοιχες ενέργειες. Αφου τελειώσει με τις ενέργεις που έχει να κάνει και απαντήσει στο μήνυμα, στέλνει ενα SIGTERM signal στον jms_console για να τον ενημερώσει οτι τελείωσε με την απάντηση.

3) Επικοινωνία jms_coord – pool: Για την επικοινωνία του jms_coord με κάθε pool δημιουργώ 2 pipes (όχι named-pipes, αφέθηκε απο τον διδάσκοντα η ελευθέρια επιλογής σε αυτό) τα οποία τα αποθηκευώ σε μία δομή κόμβου που έχω δημιουργήσει με διάφορες χρήσιμες πληροφορίες ώστε να μπορώ να χειρίζομαι την επικοινωνία με όλα τα pools.

Ο jms_coord αφου δεχτεί μία εντολή και την διαβάσει αν είναι submit, suspend , resume την κωδικοποιεί σε μορφή X|Y όπου Χ είναι το opcode της εντολής 
sumbit: X= 1, suspend: X = 6 , resume: X = 7 
και Υ οι πληροφοριές που χρειάζεται για να τρέξει κάθε εντολή.
Αν στείλει ενα μήνυμα της μορφής -1| δίνει το ΟΚ στο pool να τερματίσει!
Τις υπόλοιπες εντολές δεν χρειάζεται να τις στείλει στον pool για να πάρει απάντηση, καθώς ο jms_coord κρατάει μία δομή λίστας με όλα τα jobs που έχει δημιουργήσει μέχρι εκείνη τη στιγμή και κάθε κόμβος της αναπαριστά την κατάσταση ενος job. Με τον όρο κατάσταση εννοώ οτι κρατάει πληροφοριές για το πότε ξεκίνησε, πόσο χρόνο ήταν suspened, το αν είναι active,suspened,finished. 

Επίσης κάθε pool ενημερώνει με κατάλληλο πρωτόκολλο επικοινωνίας που υλοποίησα τον jms_coord για την κατάσταση του κάθε job όποτε αυτή αλλάξει. 
Αυτό υλοποιήθηκε ως εξής: 
	Με το που λάβει ένα SIGCHLD ο pool δηλαδή οτι τελείωσε ένα απο τα jobs του με κατάλληλο signal handler βρίσκει ποιο/α jobs τελείωσαν και στέλει στο pipe που έχει οριστεί για την επικοινωνία του με το jms_coord ένα μήνυμα της μορφής ! 1 2 ! και αυτό ο jms_coord το αντιλαμβάνεται οτι τερμάτισαν τα jobs που έχουν job_id 1 και job_id 2. Στην περίπτωση που το pool έχει φτάσει στον μέγιστο αριθμό απο jobs και όλα έχουν τερματίσει τότε στέλνει ένα μήνυμα
	! -1 ! για να ρωτήσει τον jms_coord πότε μπορεί να τερματίσει.
	Αντίστοιχα για Active job έχω: # 1 2 # ενώ για suspened jobs έχω: $ 1 2 $.


4)Path: Το όρισμα στον jms_coord για το path πρέπει να είναι της μορφής lef\Desktop\path

5)Submit: Χρησιμοποίείτε το system call execvp κατα τη δημιουργία των jobs καθώς και αν θέλουμε κάποιο path ή αρχείο να είναι της μορφής /home/lef/mysrcipt.sh.

6) Τερματισμός: Όταν το jms_console δεχτεί την εντολή shutdown τότε περιμένει απάντηση και στη συνέχεια τερματίζει και και το πρόγραμμα jms_console.


